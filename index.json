[{"title":"Accept header parser and matcher","date":"","description":"Every REST service MUST support Accept header","body":"Introduction It\u0026rsquo;s not so evident that the Accept header is an essential part of HTTP and especially REST communication. Usually people do not worry about Accept header, either I\u0026rsquo;m.\nThis short article will show how simple to add validation and matching to your HTTP router independently to the router and framework you use.\nAbout Accept header Accept header is a simple list of mime types (application/json, text/html, etc.) or wildcard rules (*/*, application/*, etc.) that a client supports. In the case of the provider Accept header, the client expects to respond with one of the matched mime types from the header.\nThis header also supports additional parameters that a client can provide per a mime type.\nThe main parameter is quality q, that defines order of rules to choose the best option for a client, for example: */*;q=0.1, application/json; q=1, application/xml; q=0.8. In this example, we prefer to receive a response in JSON. If it\u0026rsquo;s not supported, return in XML; otherwise, it does not matter the response mime type.\nThe second example is character encoding charset. If a client sets some charset, it expects to receive a response encoded.\nImplementation notes Following the description above. We can specify requirements for the Accept header parser\n Split all mime types by , symbol; Parse mime type and params; Order mime types and rules by:  Use q parameter to sort; More strict mime types have more priority than wildcards; More parameters have more priority.   Match supported mime types to Accept rules from the Accept header and find the best result for either for client and server.  Creating middleware Your router/framework can support this feature out of the box. If possible, do not spend time implementing your solution. However, read the article in case of:\n You disagree with an implementation in your framework; You need to implement support of Accept header by yourself; You want to discover more about Accept header supporting.  Background  We will use mimeheader library to parse and match mime types; Our middleware will implement http.HandlerFunc type; It\u0026rsquo;s ONLY for learning purposes, do not use it in real projects AS IS.  http/net middleware for http.HandleFunc package main import ( \u0026#34;context\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;github.com/aohorodnyk/mimeheader\u0026#34; ) func main() { r := http.NewServeMux() r.HandleFunc(\u0026#34;/\u0026#34;, acceptHeaderMiddleware([]string{\u0026#34;application/json\u0026#34;, \u0026#34;text/html\u0026#34;})(handlerTestFunc)) err := http.ListenAndServe(\u0026#34;:8080\u0026#34;, r) if err != nil { log.Fatalln(err) } } func acceptHeaderMiddleware(acceptMimeTypes []string) func(http.HandlerFunc) http.HandlerFunc { return func(next http.HandlerFunc) http.HandlerFunc { return func(rw http.ResponseWriter, r *http.Request) { header := r.Header.Get(\u0026#34;Accept\u0026#34;) ah := mimeheader.ParseAcceptHeader(header) // We do not need default mime type.  mh, mtype, m := ah.Negotiate(acceptMimeTypes, \u0026#34;\u0026#34;) if !m { // If not matched accept mim type, return 406.  rw.WriteHeader(http.StatusNotAcceptable) return } // Add matched mime type to context.  ctx := context.WithValue(r.Context(), \u0026#34;resp_content_type\u0026#34;, mtype) // Add charset, if set  chs, ok := mh.Params[\u0026#34;charset\u0026#34;] if ok { ctx = context.WithValue(ctx, \u0026#34;resp_charset\u0026#34;, chs) } // New requet from new context.  rc := r.WithContext(ctx) // Call next middleware or handler.  next(rw, rc) } } } func handlerTestFunc(rw http.ResponseWriter, r *http.Request) { mtype := r.Context().Value(\u0026#34;resp_content_type\u0026#34;).(string) charset, _ := r.Context().Value(\u0026#34;resp_charset\u0026#34;).(string) rw.Write([]byte(mtype + \u0026#34;:\u0026#34; + charset)) } Responses GET http://localhost:8080/ Accept: text/*; q=0.9,application/json; q=1; #HTTP/1.1 200 OK #Date: Sat, 03 Jul 2021 23:55:41 GMT #Content-Length: 17 #Content-Type: text/plain; charset=utf-8 # #application/json: ### GET http://localhost:8080/ Accept: text/*; q=1,application/json; q=1; charset=utf-8bm; #HTTP/1.1 200 OK #Date: Sat, 03 Jul 2021 23:56:14 GMT #Content-Length: 24 #Content-Type: text/plain; charset=utf-8 # #application/json:utf-8bm ### GET http://localhost:8080/ Accept: text/html; charset=utf-8; q=1,application/*; q=1; charset=cp1251; #HTTP/1.1 200 OK #Date: Sat, 03 Jul 2021 23:54:20 GMT #Content-Length: 14 #Content-Type: text/plain; charset=utf-8 # #text/html:utf-8 ### GET http://localhost:8080/ Accept: text/*; q=1,application/*; q=0.9; #HTTP/1.1 200 OK #Date: Sat, 03 Jul 2021 23:56:33 GMT #Content-Length: 10 #Content-Type: text/plain; charset=utf-8 # #text/html: ### GET http://localhost:8080/ Accept: text/plain; q=1,application/xml; q=1; # HTTP/1.1 406 Not Acceptable # Date: Sat, 03 Jul 2021 19:17:28 GMT # Content-Length: 0 # Connection: close Conclusion Let\u0026rsquo;s try not to forget about the Accept header even if this feature is not implemented in the current framework.\n","ref":"/blog/2021-07-03-mime-headers/"},{"title":"Quick Review of the Most Popular Ways to Implement Flags","date":"","description":"Quick introduction to different type of flags with pros and cons","body":"Introduction There are many ways to store flags and use them for communication between client \u0026lt;-\u0026gt; backend service or service \u0026lt;-\u0026gt; service. In the article, we are going to review the most popular options and we will try to help to choose the correct way for the next project.\nThe most popular ways to work with flags are:\n Store in separate column in DB or separate property in a class/struct Store as an array or in a set Store as binary data in a variable  Options Separate field It means we would create a separate column in DB for each flag.\nDB Example In an example, is_new will be a flag.\n   id username is_new     1 test1 true   2 test2 false    JSON Example In a code or a NoSQL database representation would be:\n[ { \u0026#34;id\u0026#34;: 1, \u0026#34;username\u0026#34;: \u0026#34;test1\u0026#34;, \u0026#34;is_new\u0026#34;: true }, { \u0026#34;id\u0026#34;: 2, \u0026#34;username\u0026#34;: \u0026#34;test2\u0026#34;, \u0026#34;is_new\u0026#34;: false } ] Pros  Simple to read Simple to understand Self-documented In a code it can represent as typed properties Simple to convert between different representations, like struct/class -\u0026gt; JSON -\u0026gt; protobuf -\u0026gt; MsgPack -\u0026gt; DB row -\u0026gt; struct/class Simple to use in search and aggregation requests in DB (for example by SQL) Can be updated in DB in parallel, by UPDATE query  Cons  Takes up memory/storage space/traffic Could be expensive in development or risky to remove in case of dynamically typed languages Could be expensive in development to add or remove or update in case of microservice architecture Could be expensive in development to remove from DB as a column  Use Cases In my opinion, before using this approach, we should answer \u0026ldquo;yes\u0026rdquo; for all listed options in the checklist:\n I agree to extend add and remove columns in your database (or add fields to the NoSQL database)? I understand it could take up resources in DB will be used I do not have memory and traffic sensitive clients or services  Store In Array In the current implementation, we will store all flags as strings in an array.\nDB Example In a DB, we are going to store values in a separate table as one to many relationships.\nTable user:\n   id username     1 test1   2 test2    Table user_flag\n   id user_id flag     1 1 is_new   2 1 is_test    Every user_flag row is linked to a row in user table by user_id field. It can be optimized to not store the flag as a string, but in our current topic, it is not so important.\nJSON Example In a code or a NoSQL database representation would be:\n[ { \u0026#34;id\u0026#34;: 1, \u0026#34;username\u0026#34;: \u0026#34;test1\u0026#34;, \u0026#34;flags\u0026#34;: [ \u0026#34;is_new\u0026#34;, \u0026#34;is_test\u0026#34; ] }, { \u0026#34;id\u0026#34;: 2, \u0026#34;username\u0026#34;: \u0026#34;test2\u0026#34;, \u0026#34;flags\u0026#34;: [] } ] Pros  Simple to read Simple to understand Self-documented Could be dynamically extended in a code (does not need to update code to add new flag) Simple to convert between different representations, like struct/class -\u0026gt; JSON -\u0026gt; protobuf -\u0026gt; MsgPack -\u0026gt; DB row -\u0026gt; struct/class Pretty simple to use in search and aggregation requests in DB (for example by SQL) Can be updated in DB in parallel, by INSERT query and DELETE query  Cons  Takes up memory/storage space/traffic Need to write additional code for set and unset and find functions Could affect different limitation in case of many flags Could affect performance, especially on a client-side  User Cases In my opinion, before using this approach, we should answer \u0026ldquo;yes\u0026rdquo; for all listed options in the checklist:\n I do not have performance and memory and traffic sensitive clients or services I understand it could take up resources on all sides it would be used  Store In Bitmask Bitmask is a way when we use bitwise operations to get access to specific flag. Every flag stores in binary data in memory, for example it can be stored in: byte, short, int, uint, long, []byte, []short, map[int]byte, etc.\nTo see code in action, simply read README.md from binflags library.\nDB Example In DB we can store bitmask in various types, like: TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT, BLOB types.\n   id username flags     1 test1 1   2 test2 0    In the current example, flags field has the type INT and the first bit is is_new flag.\nJSON Example In a code or a NoSQL database representation would be:\n[ { \u0026#34;id\u0026#34;: 1, \u0026#34;username\u0026#34;: \u0026#34;test1\u0026#34;, \u0026#34;flags\u0026#34;: 1 }, { \u0026#34;id\u0026#34;: 2, \u0026#34;username\u0026#34;: \u0026#34;test2\u0026#34;, \u0026#34;flags\u0026#34;: 0 } ] Pros  Simple to understand The fastest implementation for all operations with flags Do not take up additional memory and traffic resources (always only 1 bit per flag) Can be used in a search by DB (but cannot be efficiently used indexes)  Cons  In some cases flags cannot be updated in parallel Cannot search flags by index Have to be documented (name to bit mapping) Should be explained for some people  Use Cases In my opinion, before using this approach, we should answer \u0026ldquo;yes\u0026rdquo; for all listed options in the checklist:\n I want to save memory/traffic/processor resources I understand all limitations  Conclusion As we can see, as usual, we do not have silver bullet for all use cases and systems. But the provided list of implementations can help to find the best solution for a specific project.\nIf you want to use the most efficient option in Go, I would suggest checking Go implementation of binary flags for various types.\n","ref":"/blog/2021-01-03-binary-flags/"},{"title":"About","date":"","description":"About Anton Ohorodnyk","body":"I\u0026rsquo;m senior software engineer with more than 10 years of experience in backend development. I\u0026rsquo;m interested in various technologies, it\u0026rsquo;s the reason I created the blog. I like cartoons and video games, but do not spend a lot of time for playing. I\u0026rsquo;m interested in knowledge sharing and communications. Feel free to write me by any way.\n","ref":"/about/"}]